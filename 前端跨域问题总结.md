# 前端跨域问题总结

[TOC]

## 什么是跨域？
**同源策略**是所有支持JavaScript的浏览器一个安全策略，即域名、协议、端口相同。

|  URL	| 说明 | 是否允许 |
|----------|---------| --------|
|http://www.a.com/a.js / http://www.a.com/a.js |同一域名下 | 允许|
|http://www.a.com:8080/a.js / http://www.a.com/a.js |同一域名下，不同端口号 | 不允许|
|http://www.a.com/lab/a.js / http://www.a.com/script/b.js	| 同一域名下不同文件夹 |	允许 |
| http://www.a.com:8000/a.js / http://www.a.com/b.js	 | 同一域名，不同端口	|不允许|
|http://www.a.com/a.js / https://www.a.com/b.js	| 同一域名，不同协议	|不允许|
|http://www.a.com/a.js / http://70.32.92.74/b.js	 | 域名和域名对应ip	|不允许|
| http://www.a.com/a.js / http://script.a.com/b.js	| 主域相同，子域不同	|不允许|
| http://www.a.com/a.js / http://a.com/b.js	|同一域名，不同二级域名（同上）	| 不允许（cookie这种情况下也不允许访问）|
| http://www.cnblogs.com/a.js / http://www.a.com/b.js	|不同域名|	不允许|

## 跨域常用解决方案？

####  1. document.domain
> 只有在主域相同的时候才能使用该方法。
  
**a.在www.a.com/a.html中**
  
``` javascript
document.domain = 'a.com';    
```
**b.在www.script.a.com/b.html中：**
``` javascript
document.domain = 'a.com';
```

#### 2.动态创建script
>原来同jsonp相同，因为script标签不受同源策略的限制。

```javascript
function loadScript(url, func) {
  var head = document.head || document.getElementByTagName('head')[0];
  var script = document.createElement('script');
  script.src = url;

  script.onload = script.onreadystatechange = function(){
    if(!this.readyState || this.readyState=='loaded' || this.readyState=='complete'){
      func();
      script.onload = script.onreadystatechange = null;
    }
  };

  head.insertBefore(script, 0);
}
window.baidu = {
  sug: function(data){
    console.log(data);
  }
}
loadScript('http://suggestion.baidu.com/su?wd=w',function(){console.log('loaded')});
//我们请求的内容在哪里？
//我们可以在chorme调试面板的source中看到script引入的内容
```
#### 3.JSONP
>JSONP在页面插入script的标签，执行回调方法，把数据当成参数传入。
>数据被抓取和攻击比较容易，判断接口状态比较困难。
>如果要实现jsonp的数据传输，在回调的时候必须加上token之类验证。

#### 4.location.hash

> 比较特定场景使用，比较少用。
> 原理是利用location.hash来进行传值。
>假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息。
>1) cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面
>2) cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据
>3) 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值


#### 5.window.name
>window.name 的美妙之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。(借助window.name实现跨域传输数据，网上有很多现有封装，可以研究下，在此不再提供示例。实例研究：alibaba.com 缓存打点就用此方法实现，当前这个页面的用户行为全部存储在window.name，在用户访问任何下一个页面时发送出去，曾经给B2B业务代理17%的数据精准度提升。

#### 6.postMessage
[Web 浏览器跨域通信解决方法-HTML5 message](https://git.gooagoo.com/hewenshan/doc/issues/8)

#### 7.CORS
>CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。

[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)
[跨域的另一种解决方案——CORS（Cross-Origin Resource Sharing）跨域资源共享](http://www.cnblogs.com/shikyoh/p/4959562.html)
>两篇文章合起来，就解决了CORS跨域的所有的问题。

>**补充要点：** xhr.withCredentials 为true的时候，是允许js发送跨域请求时，带上cookie信息，如果false的时候不允许带上cookie信息，但前提服务端Access-Control-Allow-Credentials: true允许带上验证信息，并且Access-Control-Allow-Origin的不能为*号，只能传递包括带有端口号的一个域名，否则浏览器不允许。


#### 8.web sockets
>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)

>web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。

>web sockets 结合前后端分离中node服务将发挥更加有意义事情。

```javascript
var socket = new WebSockt('ws://www.baidu.com');
//http->ws; https->wss
socket.send('hello WebSockt');
socket.onmessage = function(event){
    var data = event.data;
}
```
